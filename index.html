<!DOCTYPE html>
<html lang="fa">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <title>راهنمای جامع زبان کاتلین</title>
    <meta name="generator" content="Jekyll v3.9.3" />
    <meta property="og:title" content="راهنمای جامع کاتلین" />
    <meta property="og:locale" content="fa" />
    <meta name="description"
        content="ریپازیتوری درباره ی زبان برنامه نویسی کاتلین به همراه تمام منابع لازم برای یادگیری" />
    <meta property="og:description"
        content="ریپازیتوری درباره ی زبان برنامه نویسی کاتلین به همراه تمام منابع لازم برای یادگیری" />
    <link rel="canonical" href="https://mirakabzi.github.io/kotlin/" />
    <meta property="og:url" content="https://mirakabzi.github.io/kotlin/" />
    <meta property="og:site_name" content="راهنمای کاتلین" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="راهنمای جامع کاتلین" />
    <script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"ریپازیتوری درباره ی زبان برنامه نویسی کاتلین به همراه تمام منابع لازم برای یادگیری","headline":"راهنمای جامع کاتلین","name":"راهنمای کاتلین","url":"https://mirakabzi.github.io/kotlin/"}</script>
    <!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/kotlin/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

    <!-- Setup Google Analytics -->



    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/kotlin-guide/favicon.ico" -->

    <!-- end custom head snippets -->

</head>

<body style="direction: rtl;">
    <div class="container-lg px-3 my-5 markdown-body">

        <h1><a href="https://unity-technologies.github.io/kotlin-guide/">راهنمای کاتلین</a></h1>


        <h1 id="kotlin-best-practises"><strong>راهنمای جامع زبان کاتلین</strong></h1>

        <h2 id="foreword">پیشگفتار</h2>

        <p>
          این سند با دو هدف تهیه شده است: نخست، به عنوان یک راهنما برای توسعه‌دهندگان تازه‌کاری طراحی شده که به‌ویژه در کار با کاتلین تجربه چندانی ندارند. این راهنما به معرفی مهم‌ترین شیوه‌های مختص کاتلین و ابزارها از دیدگاه تیم می‌پردازد. دوم، این سند به عنوان یک مرجع زنده عمل کرده و معماری‌ها و تصمیمات کدنویسی تیم را که طی فرآیند توسعه خدمات اتخاذ شده‌اند، مستندسازی می‌کند.
          </p>

        <p>
          هر سرویس همچنان گزارشی از تصمیمات معماری خود ارائه می‌دهد، اما در اینجا تصمیمات خاص، راهنماهای سبک، و نکات کلی مرتبط با سرویس‌های غیرفعال را فهرست می‌کنیم که هر فردی که با پایگاه کد ما سر و کار دارد باید از آن‌ها مطلع باشد.
        </p>

        <p>
          در حالی که این سند عمدتاً برای استفاده داخلی تیم کیف پول وجود دارد و بنابراین فقط به موارد مرتبط با نیازهای خاص ما می‌پردازد، باید نقطه شروعی برای هر تیم دیگری که می‌خواهد با کاتلین توسعه دهد، به ویژه در سمت سرور، فراهم کند.
          </p>

        <h2 id="what-is-kotlin-and-why-we-use-it">کاتلین چیست و چرا از آن استفاده می کنیم</h2>

        <p><a
                href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)">https://en.wikipedia.org/wiki/Kotlin_(programming_language)</a>
        </p>

        <p><a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>

        <p>به طور خلاصه کاتلین یک زبان تابعی دیگر برای جی وی ام است. مزایای اصلی آن نسبت به توسعه با جاوا مشابه سایر زبان‌های تابعی است.</p>

        <ul>
          <li>کاهش کد</li>  
          <li>سادگی ساختار</li>  
          <li>پوشش ناهماهنگی‌های داخلی جاوا</li>  
          <li>سازگاری با جاوا</li>
        </ul>

        <p>با این وجود، کاتلین دارای قابلیت‌هایی است که در سایر زبان‌های مشابه نادر است.</p>

        <ul>
            <li>نوع‌نگاری سخت + استنباط نوع &lt;3
                <ul>
                  <li>کاتلین زبانی با نوع‌گذاری قوی است.</li>  
                  <li>با استنباط نوع، کدهای تکراری را به‌طور چشمگیری کاهش می‌دهد.</li>
                </ul>
            </li>
            <li>ایمنی Null</li>
              <ul>
               <li>متغیرها باید به صورت صریح به عنوان نال‌پذیر تعیین شوند</li>
               <li>مدیریت مقادیر نال‌پذیر با Safecall از طریق IDE ضروری است</li>
             </ul>
            </li>
        </ul>

        <h2 id="learning-kotlin">یادگیری کاتلین</h2>

        <p>
          این سند تمامی اصول اولیه را شامل نمی‌شود. برای منابع به‌روزتر می‌توانید به <a href=https://kotlinlang.org/docs/reference/>https://kotlinlang.org/docs/reference/</a> مراجعه کنید. همچنین، کتابخانه تیم شامل <em>Kotlin in Action</em> است که اگرچه کمی پیچیده‌تر است، اما در فصل‌های نخست به خوبی تفاوت‌های اصلی کاتلین و جاوا را توضیح می‌دهد.
          </p>

        <h1 id="best-practises">نکات مهم</h1>

        <h2 id="principles">اصول</h2>

        <h3 id="keep-it-readable">آن را <strong>خوانا</strong> نگه دارید</h3>

        <p>
          در واقع، نسبت زمان صرف شده برای خواندن در مقابل نوشتن بیش از 10 به 1 است. ما دائما قدیمی می خوانیم
          کد به عنوان بخشی از تلاش برای نوشتن کد جدید. … [بنابراین،] آسان کردن خواندن آن را آسان تر می کند
          بنویسید." <em>- مارتین سی فاولر، کد تمیز</em>
          </p>

        <ul>
            <li>هرچه درک کد آسان تر باشد، منطق واقعی را راحت تر می بینید و در صورت لزوم آن را برطرف می کند
                <ul>
                  <li>از قضاوت خود بهره بگیرید  
                    <ul>
                        <li>در بیشتر موارد، خوانایی برای یک کار خاص اهمیت بالاتری نسبت به پایبندی به قرارداد دارد. با این‌ حال، پیروی از قراردادها نیز می‌تواند موجب خواناتر شدن محتوا شود. تلاش کنید تنها زمانی از قراردادها فاصله بگیرید که این کار به طور آشکاری خوانایی را بهبود دهد.</li>
                     </ul>
                   </li>
                    <li>مختصر همیشه برابر با خواندن نیست
                        <ul>
                            <li>
                              زنجیره عملکرد شما با چندین عملیات الویس که می تواند با ارسال آن به یک لامبدا گسترش یابد ممکن است واقعا جالب و هوشمندانه باشد، اما آیا درک آن آسان تر خواهد بود اگر آن را به سبک ساده قدیمی جاوا بنویسید؟
                            </li>
                        </ul>
                    </li>
                    <li>توسعه دهندگان جدید به احتمال زیاد جاوا را بهتر از کاتلین می شناسند، بنابراین هنگام نوشتن کد این را در نظر بگیرید.
                        <ul>
                            <li>اگر کاری خاص کاتلین انجام می دهید که در اینجا به آن پرداخته نشده است، در نظر بگیرید که درک آن چقدر آسان است و در صورت لزوم یک نظر به کد خود یا بخشی به این سند اضافه کنید</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h3 id="keep-it-safe">آن را <strong>ایمن</strong> نگه دارید</h3>

        <ul>
            <li>از ویژگی های ایمنی اضافه شده نهایت استفاده را ببرید: تغییرناپذیری و ایمنی تهی</li>
        </ul>

        <h2 id="coding-conventions">قراردادهای کدنویسی</h2>

        <ul>
            <li>ما از کنوانسیون های رسمی کاتلین پیروی می کنیم مگر اینکه به طور خاص توسط این سند لغو شود
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/coding-conventions.html">https://kotlinlang.org/docs/reference/coding-conventions.html</a>
                    </li>
                    <li>چندین نکته از مرجع فوق نیز در این سند ذکر شده است تا آنها را برجسته کند</li>
                    <li>پیروی از قراردادهای کدنویسی عمومی برای بیشتر موارد مهم است زیرا این امر درک کد ما را برای توسعه دهندگان جدید آسان تر می کند، اما مواقعی وجود دارد که مشکل خاص شما می تواند به روشی غیر ساده حل شود که در واقع در آن مورد خاص قابل خواندن تر است.</li>
                </ul>
            </li>
        </ul>

        <h2 id="safe-variable-declarations">اعلان های متغیر ایمن</h2>

        <ul>
            <li>همیشه در صورت امکان از <strong>یک نوع غیر قابل انکار</strong> استفاده کنید
              </li>
            <li>همیشه متغیرها را به عنوان <strong>val</strong> اعلام کنید مگر اینکه دلیل خاصی برای استفاده از <em>var</em> داشته باشید
            </li>
            <li>همچنین از <strong>کالکشن های تغییرناپذیر</strong> به جای کالکشن های قابل تغییر استفاده کنید</li>
            <li>اگر لازم است متغیری را قبل از اختصاص دادن یک مقدار به جای nullable اعلام کنید، آن را به صورت
                <strong>lateinit</strong>
                <ul>
                    <li>اگر متوجه شدید که این کار را انجام می دهید، بررسی کنید که آیا باید کد خود را به یک اعلان لامبدا تغییر دهید تا به جای آن مقدار را مقداردهی اولیه کنید.
                        <ul>
                            <li>e.g. <em>val x = { when (y) { … } }</em></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
              استفاده از <strong>تماس های ایمن</strong> و <strong>عملگر elvis</strong> با متغیرهای nullable
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls">https://kotlinlang.org/docs/reference/null-safety.html#safe-calls</a>
                    </li>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator">https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator</a>
                    </li>
                    <li><em><strong>استفاده نکنید !!</strong></em> برای اجباری کردن استثنائات اشاره گر تهی</li>
                </ul>
            </li>
        </ul>

        <h2 id="use-when">از <em><strong>when</strong></em> استفاده کنید</h2>

        <p><a
                href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression">https://kotlinlang.org/docs/reference/control-flow.html#when-expression</a>
        </p>

        <p>در جاوا شما عمدتا از عبارت <em>switch</em> همراه با enums استفاده می کنید. سوئیچ در کاتلین با <em>زمانی</em> جایگزین شده است که می تواند و باید برای آرایه بسیار گسترده تری از مدیریت جریان استفاده شود.</p>

        <ul>
            <li>
              اگر یک بلوک کد دارید که <strong>بیش از یک <em>if-statement</em></strong> دارد، تقریبا همیشه <strong>باید آن را به <em>یک زمان</em> تغییر</strong> دهید.
              </li>
            <li>
              اگر ساختار <em>if</em> دارید که فقط با چک های بولین است، گاهی اوقات می تواند با ساختارهای <em>if</em> خوانا تر باشد، بنابراین از عقل سلیم استفاده کنید
              </li>
        </ul>

        <h2 id="classes-and-functions">کلاس ها و توابع</h2>

        <h3 id="declaring-multiple-classes-in-one-file">اعلام چندین کلاس در یک فایل</h3>

        <ul>
            <li>تعریف کلاس های به شدت مرتبط در همان فایل را در نظر بگیرید
                <ul>
                    <li>کلاس های داده ای که فقط به عنوان مقادیر بازگشتی استفاده می شوند و کلاسی که از آنها استفاده می کند</li>
                    <li>مجموعه ای از کلاس های داده و enums مورد استفاده در سراسر یک پکیج
                        <ul>
                            <li>چنین فایل مجموعه ای باید به گونه ای نامگذاری شود که به راحتی قابل شناسایی و پیوند به بسته باشد
                                <ul>
                                    <li>g. PackageNameDomainObjects.kt</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>اندازه فایل را در نظر بگیرید، حتی اگر برخی از کلاس ها اتصالات بسیار قوی دارند، ممکن است همچنان بخواهید آنها را در فایل های خود اعلام کنید تا از داشتن یک فایل یکپارچه عظیم که باید در آن پیمایش کنید جلوگیری کنید.</li>
        </ul>

        <h3 id="constructors">سازنده</h3>

        <ul>
            <li>
              سعی کنید <strong>فقط یک <em>constructor اولیه</em></strong> و در صورت لزوم یک <em>بلوک init</em> تعریف کنید
                  </li>
            <li>به جای بارگذاری بیش از حد constructor به عنوان constructors ثانویه<strong>، آرگومان های پیش فرض را ارائه می دهند</strong>
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/functions.html#default-arguments">https://kotlinlang.org/docs/reference/functions.html#default-arguments</a>
                    </li>
                    <li>تعریف سازندگان پشتیبانی می شود اما توصیه نمی شود زیرا شما باید بتوانید با آرگومان های پیش فرض به همان اثر دست یابید و بهتر است به یک روش برای انجام کارها پایبند باشید</li>
                    <li>
                      احتمالا برای ما مرتبط نیست، اما اگر نیاز به ایجاد شی کاتلین خود با آرگومان های پیش فرض از یک کلاس جاوا دارید، احتمالا باید از <em>حاشیه نویسی @JavaOverloads</em> استفاده کنید.
                      </li>
                </ul>
            </li>
            <li>و در سمت فراخوانی شما باید از <strong>آرگومان های نامگذاری</strong> شده استفاده کنید هر زمان که تمام استدلال های ممکن را رد نمی کنید
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/functions.html#named-arguments">https://kotlinlang.org/docs/reference/functions.html#named-arguments</a>
                    </li>
                </ul>
            </li>
        </ul>

        <h3 id="parameter-and-state-validation">اعتبار سنجی پارامتر و حالت</h3>

        <ul>
            <li>
              اگر نیاز به اعتبارسنجی مقادیر پارامتر دارید، باید این کار را به صراحت با استفاده از <strong>یک بلوک نیاز</strong> انجام دهید
                  </li>
            <li>Require مشابه یک عبارت if عمل می کند که اگر نتیجه نادرست باشد، یک <em>IllegalParameterException</em> را پرتاب می کند
                <ul>
                    <li><a
                            href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html</a>
                    </li>
                    <li>قابل استفاده در constructor، بلوک های init یا هر تابعی که در آن نیاز به بررسی مقادیر پارامتر دارید</li>
                </ul>
            </li>
            <li>به همین ترتیب، اعتبارسنجی حالت باید از <strong>بلوک چک</strong> مشابه استفاده کند
                <ul>
                    <li><a
                            href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html</a>
                    </li>
                    <li><em>IllegalStateException</em> را پرتاب می کند</li>
                </ul>
            </li>
        </ul>

        <h3 id="properties-and-data-classes">ویژگی ها و کلاس های داده</h3>

        <p><a
                href="https://kotlinlang.org/docs/reference/properties.html">https://kotlinlang.org/docs/reference/properties.html</a>
        </p>

        <ul>
            <li>
              اعلام متغیرهای کلاس به عنوان عمومی و استفاده <strong>از دسترسی به ویژگی</strong> به جای setters و getters
              </li>
            <li>متغیرهای اعلام شده به عنوان var می توانند هم get و هم set را به صورت خارجی دریافت کنند و val فقط خوانده می شود.</li>
            <li>هنوز هم می توانید یک تنظیم کننده یا گیرنده صریح برای شناسه متغیری که نیاز دارید تعریف کنید، به عنوان مثال، برخی از محاسبات را روی مقدار انجام دهید و همچنان از نحو دسترسی به ویژگی در سمت فراخوانی استفاده کنید</li>
        </ul>

        <p><a
                href="https://kotlinlang.org/docs/reference/data-classes.html">https://kotlinlang.org/docs/reference/data-classes.html</a>
        </p>

        <ul>
            <li>کلاس های داده باید به طور گسترده استفاده شوند و با <strong>داده</strong> های کلمه کلیدی اعلام شوند</li>
            <li>اعلام یک کلاس به عنوان یک کلاس داده مقدار قابل توجهی از دیگ بخار را کاهش می دهد
                <ul>
                    <li>تمام پارامترهای سازنده اولیه به عنوان ویژگی ها اعلام می شوند</li>
                    <li><em>equals(), hashcode(), copy(), toString(</em>) (and <em>componentN()</em> (for
                        destructuring)) functions will be generated</li>
                    <li>E.g. <strong>data class User(val name: String, var age: Int)</strong> is a complete data class
                        implementation</li>
                </ul>
            </li>
            <li>کلاس های داده دارای یک تابع کپی ساخت هستند که می توان از آن برای ایجاد یک کپی با تغییرات مقدار استفاده کرد
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/data-classes.html#copying">https://kotlinlang.org/docs/reference/data-classes.html#copying</a>
                    </li>
                </ul>
            </li>
        </ul>

        <p>از آنجایی که بسیاری از کلاس های داده <strong>فقط توسط یک کلاس</strong> در پروژه ایجاد می شوند، در این موارد منطقی است که <strong>کلاس های داده را در همان فایل کلاس ایجاد</strong> کننده اعلام کنیم</p>

        <h3 id="scope-functions">توابع محدوده</h3>

        <ul>
            <li>Koltin پنج تابع scope را ارائه می دهد، let، run، with، apply، و همچنین، که همه برای اجرای یک بلوک کد بر روی یک شی وجود دارند. برای اطلاع از نحوه استفاده از آنها به لینک زیر مراجعه کنید:
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/scope-functions.html">https://kotlinlang.org/docs/reference/scope-functions.html</a>
                    </li>
                </ul>
            </li>
        </ul>

        <h3 id="companion-objects">اشیاء همراه</h3>

        <p><a
                href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects">https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects</a>
        </p>

        <ul>
            <li>متغیرها و توابع استاتیک را جایگزین می کند</li>
            <li>محل تعریف یک کارخانه و هر گونه توابع سریال سازی مربوط به یک کلاس داده و غیره.</li>
            <li>اگر به یک تابع کمکی استاتیک نیاز دارید که فقط هنگام برخورد با این یک کلاس خاص که باید در شی همراه نیز اعلام شود، استفاده می شود</li>
        </ul>

        <h3 id="return-values">مقدار بازگشتی</h3>

        <ul>
            <li><strong>Avoid returning null</strong> (especially on public functions)
                <ul>
                    <li><strong>Null should never be used to denote an error state</strong>
                        <ul>
                            <li>Instead throw an exception</li>
                            <li>Or consider using a sealed class (see below)</li>
                        </ul>
                    </li>
                    <li>When successful execution sometimes yields no results
                        <ul>
                            <li>If the return object is a collection simply return an empty collection</li>
                            <li>On a case-by-case basis you need to decide when it makes more sense to return a nullable
                                or simply throw an exception anyway or defining a sealed class (see below)
                                <ul>
                                    <li>This can be difficult to determine when first writing a class</li>
                                    <li>It mainly comes down to usage
                                        <ul>
                                            <li>If not returning anything is a common occurrence where no action is,
                                                other than filtering the result or similar, is required nullable might
                                                make more sense</li>
                                            <li>If returning nothing is exceptionally rare or you usually need to do
                                                some handling when it happens (log, stop execution, trigger a different
                                                function, etc) then throwing an exception is probably a better idea</li>
                                            <li>Also see the note about sealed classes below as an option, especially if
                                                returning a data class that represents the result of an external query
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>Protect your mutables from other objects making changes to them accidentally
                <ul>
                    <li>When returning a mutable collection you should upcast it to a non-mutable version
                        <ul>
                            <li>e. return mutableList as List</li>
                        </ul>
                    </li>
                    <li>Similarly you should attempt to protect your other class variables by only returning immutable
                        ones or copies of the data instead of the original.</li>
                </ul>
            </li>
            <li>Use <em>Pair</em> and <em>Triple</em> as return values sparingly
                <ul>
                    <li>Sometimes you will find yourself wanting to return a few values and for that <em>Pair</em> and
                        <em>Triple</em> are the simplest solution</li>
                    <li>However a better, if slightly more verbose, tactic is to declare a return object data class that
                        contains those values. This makes the handling more explicit and easier to read.</li>
                    <li>As a quick rule of thumb <strong>internal functions can use <em>Pairs</em> and
                            <em>Triples</em></strong> since the creation and handling will always be in the same class,
                        but <strong>public functions should instead return data classes</strong></li>
                    <li>You will notice that many Kotlin libraries do in fact use Pairs &amp; Triples as the public
                        return values, but you will also notice that to use them you will pretty much always have to go
                        to the source code to figure out what is actually returned and in what order.</li>
                </ul>
            </li>
        </ul>

        <h4 id="returning-sealed-classes">Returning sealed classes</h4>

        <p><a
                href="https://kotlinlang.org/docs/reference/sealed-classes.html">https://kotlinlang.org/docs/reference/sealed-classes.html</a>
        </p>

        <p><a
                href="https://phauer.com/2019/sealed-classes-exceptions-kotlin/">https://phauer.com/2019/sealed-classes-exceptions-kotlin/</a>
        </p>

        <ul>
            <li>The above blog post describes a nice looking way of using sealed classes to return success &amp; error
                states. Consider using it over simply throwing an exception.</li>
        </ul>

        <h3 id="chaining-collection-functions">Chaining collection functions</h3>

        <ul>
            <li>Unlike Java Stream API you do not have to explicitly declare that you want to change a collection to a
                stream and finally explicitly collect the result afterwards.
                <ul>
                    <li>This means, again, less boilerplate for simple streaming operations like mapping and filtering
                    </li>
                </ul>
            </li>
            <li>Also means each function is implicitly collected and when chaining functions each item in the collection
                must go through the function before we run the next function on them
                <ul>
                    <li>This can lead it being slower than Java stream operations which process item at a time rather
                        than chained function at a time</li>
                    <li>For this reason Kotlin introduces <em>sequences</em> which work exactly like Java streams</li>
                </ul>
            </li>
            <li>Whenever you are <strong>chaining multiple functions on a collection</strong> with more than trivial
                number of items, the best practise is to declare it as a <strong>sequence</strong>
                <ul>
                    <li><a
                            href="https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf">https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf</a>
                    </li>
                    <li>Kotlin sequences are not parallel and for massive data sets you can be better off using Java
                        parallel streams</li>
                </ul>
            </li>
        </ul>

        <h3 id="nested-lambdas">Nested lambdas</h3>

        <ul>
            <li><strong>When nesting lambdas</strong> take particular care to retain readability and you should
                <strong>avoid using the <em>‘it’</em> default parameter name</strong>, as it can get hard too see which
                lambda level <em>it</em> refers to</li>
        </ul>

        <h3 id="top-level-functions">Top level functions</h3>

        <ul>
            <li>Top level functions replace utility classes</li>
            <li>They are not declared inside a class, instead they can theoretically be declared in any file inside a
                package</li>
            <li>But best practise is to have a [Package/Domain/Etc]<strong>Utils.kt</strong> file in the package and
                declare all the top level functions in there</li>
            <li>If your <strong>utility function is only used by one class or only needed when dealing with a
                    particular</strong> class it should probably not be declared as a top level function, but instead it
                <strong>should be declared inside that class</strong> (see also Companion objects above)</li>
        </ul>

        <h3 id="closeables">Closeables</h3>

        <ul>
            <li>Some resources (streams, clients etc.) implement the Closeable interface and after using it you need to
                explicitly call close() to tell the jvm that you no longer require that resource and it can be garbage
                collected.</li>
            <li>Kotlin provides a <strong>use block</strong> that ensures that the resource is properly closed
                afterwards despite any error conditions or the like
                <ul>
                    <li><a
                            href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html</a>
                    </li>
                </ul>
            </li>
        </ul>

        <h2 id="java-libraries">Java libraries</h2>

        <ul>
            <li>Extensions can be used to modify external library behaviour either to provide a more Kotlin like
                experience or to add a layer of domain specific logic
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/extensions.html">https://kotlinlang.org/docs/reference/extensions.html</a>
                    </li>
                </ul>
            </li>
            <li>Keep in mind that Kotlin can not tell whether a Java method can return null (unless it has been
                correctly annotated) instead it returns a Platform Type
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/java-interop.html">https://kotlinlang.org/docs/reference/java-interop.html</a>
                    </li>
                </ul>
            </li>
            <li>Best practice is to <strong>assume that any return values from calls to Java code are always
                    nullable</strong> , that way the IDE will force you to use safe calls
                <ul>
                    <li>g. If you call a Java method that declares a return type of String <strong>explicitly
                            declare</strong> a variable created from that as String?
                        <ul>
                            <li>val fromJava: String? = JavaObject.method()</li>
                        </ul>
                    </li>
                    <li>Libraries may change, even if you know a Java library can never, under any circumstances, return
                        null, if it isn’t annotated you can not trust that it won’t change without you noticing</li>
                </ul>
            </li>
        </ul>

        <h2 id="style">Style</h2>

        <h2 id="tools-and-libraries">Tools and libraries</h2>

        <h3 id="logging">Logging</h3>

        <ul>
            <li>We use a lazy logging library called kotlin-logging
                <ul>
                    <li><a
                            href="https://github.com/MicroUtils/kotlin-logging">https://github.com/MicroUtils/kotlin-logging</a>
                    </li>
                </ul>
            </li>
            <li>You can create the logger variable outside of you actual class as a top level declaration</li>
            <li><a
                    href="https://github.com/MicroUtils/kotlin-logging#usage">https://github.com/MicroUtils/kotlin-logging#usage</a>
                suggest setting up an Idea live template to speed up the logger variable creation</li>
            <li>You can also have your class extend Kloggin, but that leads to having multiple ways of declaring the
                logger based on what your companion object looks like, so while cleaner looking it is not recommended
            </li>
        </ul>

        <h2 id="tips">Tips</h2>

        <h3 id="strings">Strings</h3>

        <ul>
            <li>Familiarise yourself with Kotlin String template
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates">https://kotlinlang.org/docs/reference/basic-types.html#string-templates</a>
                    </li>
                </ul>
            </li>
            <li>Triple quoted Strings, i.e. <em>”"”some string”"”</em>, are treated as literal and retain all formatting
                characters and require no escape characters</li>
        </ul>

        <h3 id="operator-overloading">Operator overloading</h3>

        <ul>
            <li>In Kotlin operators such as +, - and * are linked linked to corresponding functions and by providing
                those functions in your classes you can create some powerfully concise handling syntax in a DSL
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/operator-overloading.html">https://kotlinlang.org/docs/reference/operator-overloading.html</a>
                    </li>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/type-safe-builders.html">https://kotlinlang.org/docs/reference/type-safe-builders.html</a>
                    </li>
                </ul>
            </li>
            <li>Do not abuse this functionality, + sign already means something and regular code so using it for
                something else is misleading. <strong>Only do this inside your specific DSL</strong>!</li>
        </ul>

        <h3 id="equality">Equality</h3>

        <ul>
            <li>The == operator in Kotlin is actually also overloaded (see above) and calls .equals(). If you need to
                check for reference equality the operator is ===</li>
        </ul>



    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js"
        integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
</body>

</html>
