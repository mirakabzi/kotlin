<!DOCTYPE html>
<html lang="fa">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <title>راهنمای جامع زبان کاتلین</title>
    <meta name="generator" content="Jekyll v3.9.3" />
    <meta property="og:title" content="راهنمای جامع کاتلین" />
    <meta property="og:locale" content="fa" />
    <meta name="description"
        content="ریپازیتوری درباره ی زبان برنامه نویسی کاتلین به همراه تمام منابع لازم برای یادگیری" />
    <meta property="og:description"
        content="ریپازیتوری درباره ی زبان برنامه نویسی کاتلین به همراه تمام منابع لازم برای یادگیری" />
    <link rel="canonical" href="https://mirakabzi.github.io/kotlin/" />
    <meta property="og:url" content="https://mirakabzi.github.io/kotlin/" />
    <meta property="og:site_name" content="راهنمای کاتلین" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="راهنمای جامع کاتلین" />
    <script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"ریپازیتوری درباره ی زبان برنامه نویسی کاتلین به همراه تمام منابع لازم برای یادگیری","headline":"راهنمای جامع کاتلین","name":"راهنمای کاتلین","url":"https://mirakabzi.github.io/kotlin/"}</script>
    <!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/kotlin/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

    <!-- Setup Google Analytics -->



    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/kotlin-guide/favicon.ico" -->

    <!-- end custom head snippets -->

</head>

<body style="direction: rtl;">
    <div class="container-lg px-3 my-5 markdown-body">

        <h1><a href="https://mirakabzi.github.io/kotlin/">راهنمای کاتلین</a></h1>


        <h1 id="kotlin-best-practises"><strong>راهنمای جامع زبان کاتلین</strong></h1>

        <h2 id="foreword">پیشگفتار</h2>

        <p>
          این سند با دو هدف تهیه شده است: نخست، به عنوان یک راهنما برای توسعه‌دهندگان تازه‌کاری طراحی شده که به‌ویژه در کار با کاتلین تجربه چندانی ندارند. این راهنما به معرفی مهم‌ترین شیوه‌های مختص کاتلین و ابزارها از دیدگاه تیم می‌پردازد. دوم، این سند به عنوان یک مرجع زنده عمل کرده و معماری‌ها و تصمیمات کدنویسی تیم را که طی فرآیند توسعه خدمات اتخاذ شده‌اند، مستندسازی می‌کند.
          </p>

        <p>
          هر سرویس همچنان گزارشی از تصمیمات معماری خود ارائه می‌دهد، اما در اینجا تصمیمات خاص، راهنماهای سبک، و نکات کلی مرتبط با سرویس‌های غیرفعال را فهرست می‌کنیم که هر فردی که با پایگاه کد ما سر و کار دارد باید از آن‌ها مطلع باشد.
        </p>

        <p>
          در حالی که این سند عمدتاً برای استفاده داخلی تیم کیف پول وجود دارد و بنابراین فقط به موارد مرتبط با نیازهای خاص ما می‌پردازد، باید نقطه شروعی برای هر تیم دیگری که می‌خواهد با کاتلین توسعه دهد، به ویژه در سمت سرور، فراهم کند.
          </p>

        <h2 id="what-is-kotlin-and-why-we-use-it">کاتلین چیست و چرا از آن استفاده می کنیم</h2>

        <p><a
                href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)">https://en.wikipedia.org/wiki/Kotlin_(programming_language)</a>
        </p>

        <p><a href="https://kotlinlang.org/">https://kotlinlang.org/</a></p>

        <p>به طور خلاصه کاتلین یک زبان تابعی دیگر برای جی وی ام است. مزایای اصلی آن نسبت به توسعه با جاوا مشابه سایر زبان‌های تابعی است.</p>

        <ul>
          <li>کاهش کد</li>  
          <li>سادگی ساختار</li>  
          <li>پوشش ناهماهنگی‌های داخلی جاوا</li>  
          <li>سازگاری با جاوا</li>
        </ul>

        <p>با این وجود، کاتلین دارای قابلیت‌هایی است که در سایر زبان‌های مشابه نادر است.</p>

        <ul>
            <li>نوع‌نگاری سخت + استنباط نوع &lt;3
                <ul>
                  <li>کاتلین زبانی با نوع‌گذاری قوی است.</li>  
                  <li>با استنباط نوع، کدهای تکراری را به‌طور چشمگیری کاهش می‌دهد.</li>
                </ul>
            </li>
            <li>ایمنی Null</li>
              <ul>
               <li>متغیرها باید به صورت صریح به عنوان نال‌پذیر تعیین شوند</li>
               <li>مدیریت مقادیر نال‌پذیر با Safecall از طریق IDE ضروری است</li>
             </ul>
            </li>
        </ul>

        <h2 id="learning-kotlin">یادگیری کاتلین</h2>

        <p>
          این سند تمامی اصول اولیه را شامل نمی‌شود. برای منابع به‌روزتر می‌توانید به <a href=https://kotlinlang.org/docs/reference/>https://kotlinlang.org/docs/reference/</a> مراجعه کنید. همچنین، کتابخانه تیم شامل <em>Kotlin in Action</em> است که اگرچه کمی پیچیده‌تر است، اما در فصل‌های نخست به خوبی تفاوت‌های اصلی کاتلین و جاوا را توضیح می‌دهد.
          </p>

        <h1 id="best-practises">نکات مهم</h1>

        <h2 id="principles">اصول</h2>

        <h3 id="keep-it-readable">آن را <strong>خوانا</strong> نگه دارید</h3>

        <p>
          در واقع، نسبت زمان صرف شده برای خواندن در مقابل نوشتن بیش از 10 به 1 است. ما دائما قدیمی می خوانیم
          کد به عنوان بخشی از تلاش برای نوشتن کد جدید. … [بنابراین،] آسان کردن خواندن آن را آسان تر می کند
          بنویسید." <em>- مارتین سی فاولر، کد تمیز</em>
          </p>

        <ul>
            <li>هرچه درک کد آسان تر باشد، منطق واقعی را راحت تر می بینید و در صورت لزوم آن را برطرف می کند
                <ul>
                  <li>از قضاوت خود بهره بگیرید  
                    <ul>
                        <li>در بیشتر موارد، خوانایی برای یک کار خاص اهمیت بالاتری نسبت به پایبندی به قرارداد دارد. با این‌ حال، پیروی از قراردادها نیز می‌تواند موجب خواناتر شدن محتوا شود. تلاش کنید تنها زمانی از قراردادها فاصله بگیرید که این کار به طور آشکاری خوانایی را بهبود دهد.</li>
                     </ul>
                   </li>
                    <li>مختصر همیشه برابر با خواندن نیست
                        <ul>
                            <li>
                              زنجیره عملکرد شما با چندین عملیات الویس که می تواند با ارسال آن به یک لامبدا گسترش یابد ممکن است واقعا جالب و هوشمندانه باشد، اما آیا درک آن آسان تر خواهد بود اگر آن را به سبک ساده قدیمی جاوا بنویسید؟
                            </li>
                        </ul>
                    </li>
                    <li>توسعه دهندگان جدید به احتمال زیاد جاوا را بهتر از کاتلین می شناسند، بنابراین هنگام نوشتن کد این را در نظر بگیرید.
                        <ul>
                            <li>اگر کاری خاص کاتلین انجام می دهید که در اینجا به آن پرداخته نشده است، در نظر بگیرید که درک آن چقدر آسان است و در صورت لزوم یک نظر به کد خود یا بخشی به این سند اضافه کنید</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h3 id="keep-it-safe">آن را <strong>ایمن</strong> نگه دارید</h3>

        <ul>
            <li>از ویژگی های ایمنی اضافه شده نهایت استفاده را ببرید: تغییرناپذیری و ایمنی تهی</li>
        </ul>

        <h2 id="coding-conventions">قراردادهای کدنویسی</h2>

        <ul>
            <li>ما از کنوانسیون های رسمی کاتلین پیروی می کنیم مگر اینکه به طور خاص توسط این سند لغو شود
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/coding-conventions.html">https://kotlinlang.org/docs/reference/coding-conventions.html</a>
                    </li>
                    <li>چندین نکته از مرجع فوق نیز در این سند ذکر شده است تا آنها را برجسته کند</li>
                    <li>پیروی از قراردادهای کدنویسی عمومی برای بیشتر موارد مهم است زیرا این امر درک کد ما را برای توسعه دهندگان جدید آسان تر می کند، اما مواقعی وجود دارد که مشکل خاص شما می تواند به روشی غیر ساده حل شود که در واقع در آن مورد خاص قابل خواندن تر است.</li>
                </ul>
            </li>
        </ul>

        <h2 id="safe-variable-declarations">اعلان های متغیر ایمن</h2>

        <ul>
            <li>همیشه در صورت امکان از <strong>یک نوع غیر قابل انکار</strong> استفاده کنید
              </li>
            <li>همیشه متغیرها را به عنوان <strong>val</strong> اعلام کنید مگر اینکه دلیل خاصی برای استفاده از <em>var</em> داشته باشید
            </li>
            <li>همچنین از <strong>کالکشن های تغییرناپذیر</strong> به جای کالکشن های قابل تغییر استفاده کنید</li>
            <li>اگر لازم است متغیری را قبل از اختصاص دادن یک مقدار به جای nullable اعلام کنید، آن را به صورت
                <strong>lateinit</strong>
                <ul>
                    <li>اگر متوجه شدید که این کار را انجام می دهید، بررسی کنید که آیا باید کد خود را به یک اعلان لامبدا تغییر دهید تا به جای آن مقدار را مقداردهی اولیه کنید.
                        <ul>
                            <li>e.g. <em>val x = { when (y) { … } }</em></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
              استفاده از <strong>تماس های ایمن</strong> و <strong>عملگر elvis</strong> با متغیرهای nullable
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls">https://kotlinlang.org/docs/reference/null-safety.html#safe-calls</a>
                    </li>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator">https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator</a>
                    </li>
                    <li><em><strong>استفاده نکنید !!</strong></em> برای اجباری کردن استثنائات اشاره گر تهی</li>
                </ul>
            </li>
        </ul>

        <h2 id="use-when">از <em><strong>when</strong></em> استفاده کنید</h2>

        <p><a
                href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression">https://kotlinlang.org/docs/reference/control-flow.html#when-expression</a>
        </p>

        <p>در جاوا شما عمدتا از عبارت <em>switch</em> همراه با enums استفاده می کنید. سوئیچ در کاتلین با <em>زمانی</em> جایگزین شده است که می تواند و باید برای آرایه بسیار گسترده تری از مدیریت جریان استفاده شود.</p>

        <ul>
            <li>
              اگر یک بلوک کد دارید که <strong>بیش از یک <em>if-statement</em></strong> دارد، تقریبا همیشه <strong>باید آن را به <em>یک زمان</em> تغییر</strong> دهید.
              </li>
            <li>
              اگر ساختار <em>if</em> دارید که فقط با چک های بولین است، گاهی اوقات می تواند با ساختارهای <em>if</em> خوانا تر باشد، بنابراین از عقل سلیم استفاده کنید
              </li>
        </ul>

        <h2 id="classes-and-functions">کلاس ها و توابع</h2>

        <h3 id="declaring-multiple-classes-in-one-file">اعلام چندین کلاس در یک فایل</h3>

        <ul>
            <li>تعریف کلاس های به شدت مرتبط در همان فایل را در نظر بگیرید
                <ul>
                    <li>کلاس های داده ای که فقط به عنوان مقادیر بازگشتی استفاده می شوند و کلاسی که از آنها استفاده می کند</li>
                    <li>مجموعه ای از کلاس های داده و enums مورد استفاده در سراسر یک پکیج
                        <ul>
                            <li>چنین فایل مجموعه ای باید به گونه ای نامگذاری شود که به راحتی قابل شناسایی و پیوند به بسته باشد
                                <ul>
                                    <li>g. PackageNameDomainObjects.kt</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>اندازه فایل را در نظر بگیرید، حتی اگر برخی از کلاس ها اتصالات بسیار قوی دارند، ممکن است همچنان بخواهید آنها را در فایل های خود اعلام کنید تا از داشتن یک فایل یکپارچه عظیم که باید در آن پیمایش کنید جلوگیری کنید.</li>
        </ul>

        <h3 id="constructors">سازنده</h3>

        <ul>
            <li>
              سعی کنید <strong>فقط یک <em>constructor اولیه</em></strong> و در صورت لزوم یک <em>بلوک init</em> تعریف کنید
                  </li>
            <li>به جای بارگذاری بیش از حد constructor به عنوان constructors ثانویه<strong>، آرگومان های پیش فرض را ارائه می دهند</strong>
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/functions.html#default-arguments">https://kotlinlang.org/docs/reference/functions.html#default-arguments</a>
                    </li>
                    <li>تعریف سازندگان پشتیبانی می شود اما توصیه نمی شود زیرا شما باید بتوانید با آرگومان های پیش فرض به همان اثر دست یابید و بهتر است به یک روش برای انجام کارها پایبند باشید</li>
                    <li>
                      احتمالا برای ما مرتبط نیست، اما اگر نیاز به ایجاد شی کاتلین خود با آرگومان های پیش فرض از یک کلاس جاوا دارید، احتمالا باید از <em>حاشیه نویسی @JavaOverloads</em> استفاده کنید.
                      </li>
                </ul>
            </li>
            <li>و در سمت فراخوانی شما باید از <strong>آرگومان های نامگذاری</strong> شده استفاده کنید هر زمان که تمام استدلال های ممکن را رد نمی کنید
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/functions.html#named-arguments">https://kotlinlang.org/docs/reference/functions.html#named-arguments</a>
                    </li>
                </ul>
            </li>
        </ul>

        <h3 id="parameter-and-state-validation">اعتبار سنجی پارامتر و حالت</h3>

        <ul>
            <li>
              اگر نیاز به اعتبارسنجی مقادیر پارامتر دارید، باید این کار را به صراحت با استفاده از <strong>یک بلوک نیاز</strong> انجام دهید
                  </li>
            <li>Require مشابه یک عبارت if عمل می کند که اگر نتیجه نادرست باشد، یک <em>IllegalParameterException</em> را پرتاب می کند
                <ul>
                    <li><a
                            href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html</a>
                    </li>
                    <li>قابل استفاده در constructor، بلوک های init یا هر تابعی که در آن نیاز به بررسی مقادیر پارامتر دارید</li>
                </ul>
            </li>
            <li>به همین ترتیب، اعتبارسنجی حالت باید از <strong>بلوک چک</strong> مشابه استفاده کند
                <ul>
                    <li><a
                            href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html</a>
                    </li>
                    <li><em>IllegalStateException</em> را پرتاب می کند</li>
                </ul>
            </li>
        </ul>

        <h3 id="properties-and-data-classes">ویژگی ها و کلاس های داده</h3>

        <p><a
                href="https://kotlinlang.org/docs/reference/properties.html">https://kotlinlang.org/docs/reference/properties.html</a>
        </p>

        <ul>
            <li>
              اعلام متغیرهای کلاس به عنوان عمومی و استفاده <strong>از دسترسی به ویژگی</strong> به جای setters و getters
              </li>
            <li>متغیرهای اعلام شده به عنوان var می توانند هم get و هم set را به صورت خارجی دریافت کنند و val فقط خوانده می شود.</li>
            <li>هنوز هم می توانید یک تنظیم کننده یا گیرنده صریح برای شناسه متغیری که نیاز دارید تعریف کنید، به عنوان مثال، برخی از محاسبات را روی مقدار انجام دهید و همچنان از نحو دسترسی به ویژگی در سمت فراخوانی استفاده کنید</li>
        </ul>

        <p><a
                href="https://kotlinlang.org/docs/reference/data-classes.html">https://kotlinlang.org/docs/reference/data-classes.html</a>
        </p>

        <ul>
            <li>کلاس های داده باید به طور گسترده استفاده شوند و با <strong>داده</strong> های کلمه کلیدی اعلام شوند</li>
            <li>اعلام یک کلاس به عنوان یک کلاس داده مقدار قابل توجهی از دیگ بخار را کاهش می دهد
                <ul>
                    <li>تمام پارامترهای سازنده اولیه به عنوان ویژگی ها اعلام می شوند</li>
                    <li><em>equals(), hashcode(), copy(), toString(</em>) (and <em>componentN()</em> (for
                        destructuring)) functions will be generated</li>
                    <li>E.g. <strong>data class User(val name: String, var age: Int)</strong> is a complete data class
                        implementation</li>
                </ul>
            </li>
            <li>کلاس های داده دارای یک تابع کپی ساخت هستند که می توان از آن برای ایجاد یک کپی با تغییرات مقدار استفاده کرد
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/data-classes.html#copying">https://kotlinlang.org/docs/reference/data-classes.html#copying</a>
                    </li>
                </ul>
            </li>
        </ul>

        <p>از آنجایی که بسیاری از کلاس های داده <strong>فقط توسط یک کلاس</strong> در پروژه ایجاد می شوند، در این موارد منطقی است که <strong>کلاس های داده را در همان فایل کلاس ایجاد</strong> کننده اعلام کنیم</p>

        <h3 id="scope-functions">توابع محدوده</h3>

        <ul>
            <li>Koltin پنج تابع scope را ارائه می دهد، let، run، with، apply، و همچنین، که همه برای اجرای یک بلوک کد بر روی یک شی وجود دارند. برای اطلاع از نحوه استفاده از آنها به لینک زیر مراجعه کنید:
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/scope-functions.html">https://kotlinlang.org/docs/reference/scope-functions.html</a>
                    </li>
                </ul>
            </li>
        </ul>

        <h3 id="companion-objects">اشیاء همراه</h3>

        <p><a
                href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects">https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects</a>
        </p>

        <ul>
            <li>متغیرها و توابع استاتیک را جایگزین می کند</li>
            <li>محل تعریف یک کارخانه و هر گونه توابع سریال سازی مربوط به یک کلاس داده و غیره.</li>
            <li>اگر به یک تابع کمکی استاتیک نیاز دارید که فقط هنگام برخورد با این یک کلاس خاص که باید در شی همراه نیز اعلام شود، استفاده می شود</li>
        </ul>

        <h3 id="return-values">مقدار بازگشتی</h3>

        <ul>
            <li><strong>از بازگرداندن null خودداری</strong> کنید (به ویژه در عملکردهای عمومی)
                <ul>
                    <li><strong>از Null هرگز نباید برای نشان دادن وضعیت خطا استفاده شود</strong>
                        <ul>
                          <li>در عوض یک استثنا ایجاد</li> کنید
                          <li>یا استفاده از یک کلاس مهر و موم شده را در نظر بگیرید (به زیر مراجعه کنید)</li>
                        </ul>
                    </li>
                    <li>هنگامی که اجرای موفقیت آمیز گاهی اوقات هیچ نتیجه ای به همراه ندارد
                        <ul>
                            <li>اگر شی برگشتی یک مجموعه است، به سادگی یک مجموعه خالی را برگردانید</li>
                            <li>به صورت موردی باید تصمیم بگیرید که چه زمانی بازگرداندن یک nullable منطقی تر است
                              یا به سادگی یک استثنا را به هر حال پرتاب کنید یا یک کلاس مهر و موم شده را تعریف کنید (به زیر مراجعه کنید)
                                <ul>
                                    <li>تعیین این موضوع هنگام نوشتن یک کلاس می تواند دشوار باشد</li>
                                    <li>این عمدتا به استفاده برمی گردد
                                        <ul>
                                            <li>اگر برگرداندن چیزی یک اتفاق رایج است که در آن هیچ اقدامی وجود ندارد، به غیر از فیلتر کردن نتیجه یا موارد مشابه، مورد نیاز است، nullable ممکن است منطقی تر باشد

                                            </li>
                                            <li>
                                              اگر بازگرداندن چیزی بسیار نادر است یا معمولا باید در صورت وقوع آن مقداری مدیریت کنید (ورود به سیستم، توقف اجرا، راه اندازی یک عملکرد متفاوت و غیره) احتمالا پرتاب یک استثنا ایده بهتری است
                                              </li>
                                            <li>
                                              همچنین یادداشت مربوط به کلاس های مهر و موم شده را در زیر به عنوان یک گزینه ببینید، به خصوص اگر یک کلاس داده را برگردانید که نتیجه یک پرس و جو خارجی را نشان می دهد
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>از تغییر شکل های خود در برابر اشیاء دیگری که به طور تصادفی در آنها تغییراتی ایجاد می کنند محافظت کنید
                <ul>
                    <li>هنگام بازگرداندن یک مجموعه قابل تغییر، باید آن را به یک نسخه غیرقابل تغییر منتقل کنید
                        <ul>
                            <li>e. تغییر لیست را به عنوان لیست برگردانید</li>
                        </ul>
                    </li>
                    <li>به طور مشابه، شما باید سعی کنید از سایر متغیرهای کلاس خود فقط با بازگرداندن متغیرهای تغییرناپذیر یا کپی داده ها به جای اصل محافظت کنید.</li>
                </ul>
            </li>
            <li>استفاده <em>از Pair</em> و <em>Triple</em> به عنوان مقادیر بازگشتی به مقدار کم
                <ul>
                    <li>گاهی اوقات متوجه می شوید که می خواهید چند مقدار را برگردانید و برای آن <em>Pair</em> و <em>Triple</em> ساده ترین راه حل هستند</li>
                    <li>با این حال، یک تاکتیک بهتر، اگر کمی پرحرف تر، اعلام یک کلاس داده شی برگشتی است که حاوی آن مقادیر است. این باعث می شود که مدیریت صریح تر و خواندن آن آسان تر شود.</li>
                    <li>به عنوان یک قاعده سرانگشتی سریع، <strong>توابع داخلی می توانند از <em>Pairs</em> و <em>Triples</em> استفاده</strong> کنند، زیرا ایجاد و مدیریت همیشه در یک کلاس خواهد بود، اما <strong>توابع عمومی باید در عوض کلاس های داده را برگردانند</strong></li>
                    <li>متوجه خواهید شد که بسیاری از کتابخانه های کاتلین در واقع از Pairs &amp; Triples به عنوان مقادیر بازگشتی استفاده می کنند، اما همچنین متوجه خواهید شد که برای استفاده از آنها تقریبا همیشه باید به کد منبع بروید تا بفهمید چه چیزی واقعا و به چه ترتیبی بازگردانده می شود.</li>
                </ul>
            </li>
        </ul>

        <h4 id="returning-sealed-classes">بازگرداندن کلاس های مهر و موم شده</h4>

        <p><a
                href="https://kotlinlang.org/docs/reference/sealed-classes.html">https://kotlinlang.org/docs/reference/sealed-classes.html</a>
        </p>

        <p><a
                href="https://phauer.com/2019/sealed-classes-exceptions-kotlin/">https://phauer.com/2019/sealed-classes-exceptions-kotlin/</a>
        </p>

        <ul>
            <li>وبلاگ بالا روشی زیبا برای استفاده از کلاس های مهر و موم شده برای بازگرداندن حالت های موفقیت و خطا را توصیف می کند. استفاده از آن را به جای انداختن یک استثنا در نظر بگیرید.</li>
        </ul>

        <h3 id="chaining-collection-functions">توابع مجموعه زنجیره ای</h3>

        <ul>
            <li>برخلاف Java Stream API لازم نیست صریحا اعلام کنید که می خواهید یک مجموعه را به یک جریان تغییر دهید و در نهایت پس از آن به صراحت نتیجه را جمع آوری کنید.
                <ul>
                    <li>این بدان معناست که باز هم برای عملیات پخش ساده مانند نقشه برداری و فیلتر کردن کمتر است
                    </li>
                </ul>
            </li>
            <li>همچنین به این معنی است که هر تابع به طور ضمنی جمع آوری می شود و هنگام زنجیره سازی توابع، هر مورد در مجموعه باید قبل از اجرای تابع بعدی روی آنها از طریق تابع عبور کند
                <ul>
                    <li>این می تواند باعث شود که کندتر از عملیات جریان جاوا باشد که آیتم را در یک زمان به جای عملکرد زنجیره ای در یک زمان پردازش می کند</li>
                    <li>به همین دلیل، کاتلین <em>دنباله هایی</em> را معرفی می کند که دقیقا مانند جریان های جاوا کار می کنند</li>
                </ul>
            </li>
            <li>هر زمان که <strong>چندین تابع را در یک مجموعه</strong> با بیش از تعداد ناچیز آیتم ها زنجیر می کنید، بهترین روش این است که آن را به عنوان یک <strong>دنباله اعلام کنید</strong>
                <ul>
                    <li><a
                            href="https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf">https://blog.kotlin-academy.com/effective-kotlin-use-sequence-for-bigger-collections-with-more-than-one-processing-step-649a15bb4bf</a>
                    </li>
                    <li>دنباله های کاتلین موازی نیستند و برای مجموعه داده های عظیم می توانید از جریان های موازی جاوا استفاده کنید</li>
                </ul>
            </li>
        </ul>

        <h3 id="nested-lambdas">لامبدا تو در تو</h3>

        <ul>
            <li><strong>هنگام تودرتو کردن لامبداها</strong> برای حفظ خوانایی دقت ویژه ای داشته باشید و باید <strong>از استفاده از نام پارامتر پیش فرض <em>"it"</em> خودداری</strong> کنید، زیرا ممکن است سخت باشد که ببینید <em>به کدام سطح</em> لامبدا اشاره می کند</li>
        </ul>

        <h3 id="top-level-functions">توابع سطح بالا</h3>

        <ul>
            <li>توابع سطح بالا جایگزین کلاس های ابزار می شوند</li>
            <li>آنها در داخل یک کلاس اعلام نمی شوند، در عوض می توانند از نظر تئوری در هر فایلی در یک بسته اعلام شوند</li>
            <li>اما بهترین روش این است که یک فایل [Package/Domain/<strong>Etc]Utils.kt</strong> در بسته داشته باشید و تمام توابع سطح بالا را در آنجا اعلام کنید</li>
            <li>اگر <strong>تابع ابزار شما فقط توسط یک کلاس استفاده می شود یا فقط هنگام برخورد با یک کلاس خاص مورد نیاز</strong> است، احتمالا نباید به عنوان یک تابع سطح بالا اعلام شود، بلکه باید <strong>در داخل آن کلاس اعلام</strong> شود (همچنین به اشیاء همراه در بالا مراجعه کنید)</li>
        </ul>

        <h3 id="closeables">قابلیت close</h3>

        <ul>
            <li>برخی از منابع (جریان ها، کلاینت ها و غیره) رابط Closeable را پیاده سازی می کنند و پس از استفاده از آن باید صریحا close() را فراخوانی کنید تا به jvm بگویید که دیگر به آن منبع نیاز ندارید و می توان آن را زباله جمع آوری کرد.</li>
            <li>کاتلین یک <strong>بلوک استفاده</strong> را ارائه می دهد که تضمین می کند منبع پس از آن با وجود هر گونه شرایط خطا یا موارد مشابه به درستی بسته می شود
                <ul>
                    <li><a
                            href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html</a>
                    </li>
                </ul>
            </li>
        </ul>

        <h2 id="java-libraries">کتابخانه های جاوایی</h2>

        <ul>
            <li>از برنامه های افزودنی می توان برای تغییر رفتار کتابخانه خارجی استفاده کرد تا تجربه ای شبیه کاتلین ارائه دهد یا لایه ای از منطق خاص دامنه را اضافه کند
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/extensions.html">https://kotlinlang.org/docs/reference/extensions.html</a>
                    </li>
                </ul>
            </li>
            <li>به خاطر داشته باشید که کاتلین نمی تواند بگوید که آیا یک روش جاوا می تواند null را برگرداند یا خیر (مگر اینکه به درستی حاشیه نویسی شده باشد) در عوض یک نوع پلتفرم را برمی گرداند
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/java-interop.html">https://kotlinlang.org/docs/reference/java-interop.html</a>
                    </li>
                </ul>
            </li>
            <li>بهترین روش این است که <strong>فرض کنید هر مقدار برگشتی از تماس ها به کد جاوا همیشه null</strong> است، به این ترتیب IDE شما را مجبور به استفاده از تماس های ایمن می کند.
                <ul>
                    <li>g. اگر یک روش جاوا را فراخوانی کنید که نوع بازگشتی رشته را اعلام می کند، <strong>به صراحت</strong> متغیری را که از آن ایجاد شده است به عنوان رشته اعلام کنید؟
                        <ul>
                            <li>val fromJava: String? = JavaObject.method()</li>
                        </ul>
                    </li>
                    <li>کتابخانه ها ممکن است تغییر کنند، حتی اگر بدانید که یک کتابخانه جاوا هرگز نمی تواند تحت هیچ شرایطی null را برگرداند، اگر حاشیه نویسی نشده باشد، نمی توانید اعتماد کنید که بدون توجه شما تغییر نخواهد کرد</li>
                </ul>
            </li>
        </ul>

        <h2 id="style">استایل</h2>

        <h2 id="tools-and-libraries">ابزارها و کتابخانه ها</h2>

        <h3 id="logging">ورود</h3>

        <ul>
            <li>ما از یک کتابخانه لاگینگ به نام kotlin-logging استفاده می کنیم
                <ul>
                    <li><a
                            href="https://github.com/MicroUtils/kotlin-logging">https://github.com/MicroUtils/kotlin-logging</a>
                    </li>
                </ul>
            </li>
            <li>شما می توانید متغیر logger را خارج از کلاس واقعی خود به عنوان یک اعلان سطح بالا ایجاد کنید</li>
            <li><a
                    href="https://github.com/MicroUtils/kotlin-logging#usage">https://github.com/MicroUtils/kotlin-logging#usage</a>
                    پیشنهاد راه اندازی یک الگوی زنده ایده برای سرعت بخشیدن به ایجاد متغیر لاگر</li>
            <li>همچنین می توانید از کلاس خود بخواهید Kloggin را گسترش دهد، اما این منجر به داشتن روش های متعددی برای اعلام لاگر بر اساس ظاهر شی همراه شما می شود، بنابراین در حالی که تمیزتر به نظر می رسد، توصیه نمی شود
            </li>
        </ul>

        <h2 id="tips">نکات</h2>

        <h3 id="strings">رشته ها</h3>

        <ul>
            <li>با قالب Kotlin String آشنا شوید
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates">https://kotlinlang.org/docs/reference/basic-types.html#string-templates</a>
                    </li>
                </ul>
            </li>
            <li>رشته های نقل قول سه گانه، یعنی <em>"""برخی از رشته"</em>""، به عنوان تحت اللفظی در نظر گرفته می شوند و تمام کاراکترهای قالب بندی را حفظ می کنند و نیازی به کاراکترهای فرار ندارند</li>
        </ul>

        <h3 id="operator-overloading">Operator overloading</h3>

        <ul>
            <li>در کاتلین عملگرهایی مانند +، - و * به توابع مربوطه مرتبط هستند و با ارائه آن توابع در کلاس های خود می توانید نحو مدیریت بسیار مختصر را در DSL ایجاد کنید
                <ul>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/operator-overloading.html">https://kotlinlang.org/docs/reference/operator-overloading.html</a>
                    </li>
                    <li><a
                            href="https://kotlinlang.org/docs/reference/type-safe-builders.html">https://kotlinlang.org/docs/reference/type-safe-builders.html</a>
                    </li>
                </ul>
            </li>
            <li>از این قابلیت سوء استفاده نکنید، + sign در حال حاضر به معنای چیزی و کد معمولی است، بنابراین استفاده از آن برای چیز دیگری گمراه کننده است. این <strong>کار را فقط در DSL خاص خود انجام</strong> دهید!</li>
        </ul>

        <h3 id="equality">تساوی یا برابری</h3>

        <ul>
            <li>عملگر == در کاتلین نیز در واقع بیش از حد بارگذاری شده است (به بالا مراجعه کنید) و .equals() را فراخوانی می کند. اگر نیاز دارید
              برابری مرجع را بررسی کنید عملگر === است</li>
        </ul>

        <h3>آموزش کاتلین از ویدیو های فارسی زبان</h3>
        <p>
          اگر به دنبال یادگیری زبان برنامه نویسی کاتلین هستید میتوانید از دوره ی آموزش کاتلین سایت آواسام استفاده کنید 
          <a href="https://avasam.ir/product/48">ثبت نام در دوره کاتلین</a>
        </p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js"
        integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
</body>

</html>
